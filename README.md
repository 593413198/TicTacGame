## 井字棋AI的实现
**开始时间：**
`2019/4/29`

**搭建环境：**   
`Ubuntu 18.04  gcc 7.3.0`

**游戏规则：**
```
+---+---+---+    +---+---+---+
|   |   |   |    | O |   | X | 
|---|---|---|    |---|---|---|
|   |   |   |    | O | O | X |
|---|---|---|    |---|---|---|
|   |   |   |    | O | X |   | 
+---+---+---+    +---+---+---+
如图3*3的棋盘，先手落"O"，后手落"X"；若横、竖、斜方向出现三子连线，则胜出；
如右图，先手方"O"胜出:
```

## 思路分析：
**1.0 代码架构（已实现部分）**
```c
ChessBoard.h    /* 棋子、棋盘的定义、存储
ChessBoard.cpp   * 检查是否分出胜负
	             * 可视化打印棋盘 */

PlayGame.h      /* 回溯遍历所有情形
PlayGame.cpp     *                */

test.cpp        /* 测试主函数  */
Makefile        /* make编译    */
```

**1.1 先回溯遍历所有情形，摸个底**
```c
1. 暴力穷举所有局面，共有9!种可能，即362880种；
2. 考虑到产生输赢游戏就结束，有些局面不用继续搜索下去，解空间缩小为113416种，先手胜平负的局面占比分别是49%,23%,28%，因此理论上先手占优；(通过代码遍历得出,尽管实际中这种数据没任何意义)
3. 通过对称性可以进一步缩小解空间，此处省略；
4. 回溯法核心伪代码：
Go(depth){
	if (depth==9)
		return;
	do 找到空位置(i,j)并落子;
	if (胜负已分)
		Go(depth+1);
	do 将(i,j)上的落子还原;
}
```

**1.2 可视化打印棋盘，方便检查局面**
```c
#include "ChessBoard.h"
void ShowBoard(); //可视化打印
char Graph[3][3]; //空则为' '，先手'O'，后手'X'
//通过规范化的输出实现棋盘
```

**1.3 尝试模拟博弈: 对于任一种局面，判断是否存在最终获胜的子节点**
>以下全部建立在，所有局面都可能且必然会出现，即博弈双方零智能的情况下
```c
#include "PlayGame.h"
//给一个输入接口，用来检测判断的正确性
int WhoTurn;  //当前落子方
bool CanWin;  //落子方能否赢
int Sum();    //返回输入局面的落子数，即回合数
bool Input(); //输入一个局面，判断当前落子方是否有赢的可能

```

